{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.deferWith = exports.triggerAsync = exports.trigger = exports.listen = exports.shouldEmit = exports.preEmit = undefined;\n\nvar _utils = require(\"./utils\");\n\nvar _ = _interopRequireWildcard(_utils);\n\nfunction _interopRequireWildcard(obj) {\n  if (obj && obj.__esModule) {\n    return obj;\n  } else {\n    var newObj = {};\n\n    if (obj != null) {\n      for (var key in obj) {\n        if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];\n      }\n    }\n\n    newObj.default = obj;\n    return newObj;\n  }\n}\n/**\r\n * A module of methods for object that you want to be able to listen to.\r\n * This module is consumed by `createStore` and `createAction`\r\n */\n\n/**\r\n * Hook used by the publisher that is invoked before emitting\r\n * and before `shouldEmit`. The arguments are the ones that the action\r\n * is invoked with. If this function returns something other than\r\n * undefined, that will be passed on as arguments for shouldEmit and\r\n * emission.\r\n */\n\n\nvar preEmit = exports.preEmit = function preEmit() {};\n/**\r\n * Hook used by the publisher after `preEmit` to determine if the\r\n * event should be emitted with given arguments. This may be overridden\r\n * in your application, default implementation always returns true.\r\n *\r\n * @returns {Boolean} true if event should be emitted\r\n */\n\n\nvar shouldEmit = exports.shouldEmit = function shouldEmit() {\n  return true;\n};\n/**\r\n * Subscribes the given callback for action triggered\r\n *\r\n * @param {Function} callback The callback to register as event handler\r\n * @param {Mixed} [optional] bindContext The context to bind the callback with\r\n * @returns {Function} Callback that unsubscribes the registered event handler\r\n */\n\n\nvar listen = exports.listen = function listen(callback, bindContext) {\n  bindContext = bindContext || this;\n\n  var eventHandler = function eventHandler(args) {\n    if (aborted) {\n      return;\n    }\n\n    callback.apply(bindContext, args);\n  },\n      me = this,\n      aborted = false;\n\n  this.emitter.addListener(this.eventLabel, eventHandler);\n  return function () {\n    aborted = true;\n    me.emitter.removeListener(me.eventLabel, eventHandler);\n  };\n};\n/**\r\n * Publishes an event using `this.emitter` (if `shouldEmit` agrees)\r\n */\n\n\nvar trigger = exports.trigger = function trigger() {\n  var args = arguments,\n      pre = this.preEmit.apply(this, args);\n  args = pre === undefined ? args : _.isArguments(pre) ? pre : [].concat(pre);\n\n  if (this.shouldEmit.apply(this, args)) {\n    this.emitter.emit(this.eventLabel, args);\n  }\n};\n/**\r\n * Tries to publish the event on the next tick\r\n */\n\n\nvar triggerAsync = exports.triggerAsync = function triggerAsync() {\n  var args = arguments,\n      me = this;\n\n  _.nextTick(function () {\n    me.trigger.apply(me, args);\n  });\n};\n/**\r\n * Wraps the trigger mechanism with a deferral function.\r\n *\r\n * @param {Function} callback the deferral function,\r\n *        first argument is the resolving function and the\r\n *        rest are the arguments provided from the previous\r\n *        trigger invocation\r\n */\n\n\nvar deferWith = exports.deferWith = function deferWith(callback) {\n  var oldTrigger = this.trigger,\n      ctx = this,\n      resolver = function resolver() {\n    oldTrigger.apply(ctx, arguments);\n  };\n\n  this.trigger = function () {\n    callback.apply(ctx, [resolver].concat([].splice.call(arguments, 0)));\n  };\n};","map":{"version":3,"sources":["/home/tudor/work/sd/assignment-2-Lolkekzor/project/frontend/node_modules/reflux-core/lib/PublisherMethods.js"],"names":["Object","defineProperty","exports","value","deferWith","triggerAsync","trigger","listen","shouldEmit","preEmit","undefined","_utils","require","_","_interopRequireWildcard","obj","__esModule","newObj","key","prototype","hasOwnProperty","call","default","callback","bindContext","eventHandler","args","aborted","apply","me","emitter","addListener","eventLabel","removeListener","arguments","pre","isArguments","concat","emit","nextTick","oldTrigger","ctx","resolver","splice"],"mappings":"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","sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.deferWith = exports.triggerAsync = exports.trigger = exports.listen = exports.shouldEmit = exports.preEmit = undefined;\n\nvar _utils = require(\"./utils\");\n\nvar _ = _interopRequireWildcard(_utils);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\n/**\r\n * A module of methods for object that you want to be able to listen to.\r\n * This module is consumed by `createStore` and `createAction`\r\n */\n\n/**\r\n * Hook used by the publisher that is invoked before emitting\r\n * and before `shouldEmit`. The arguments are the ones that the action\r\n * is invoked with. If this function returns something other than\r\n * undefined, that will be passed on as arguments for shouldEmit and\r\n * emission.\r\n */\nvar preEmit = exports.preEmit = function preEmit() {};\n\n/**\r\n * Hook used by the publisher after `preEmit` to determine if the\r\n * event should be emitted with given arguments. This may be overridden\r\n * in your application, default implementation always returns true.\r\n *\r\n * @returns {Boolean} true if event should be emitted\r\n */\nvar shouldEmit = exports.shouldEmit = function shouldEmit() {\n    return true;\n};\n\n/**\r\n * Subscribes the given callback for action triggered\r\n *\r\n * @param {Function} callback The callback to register as event handler\r\n * @param {Mixed} [optional] bindContext The context to bind the callback with\r\n * @returns {Function} Callback that unsubscribes the registered event handler\r\n */\nvar listen = exports.listen = function listen(callback, bindContext) {\n    bindContext = bindContext || this;\n    var eventHandler = function eventHandler(args) {\n        if (aborted) {\n            return;\n        }\n        callback.apply(bindContext, args);\n    },\n        me = this,\n        aborted = false;\n    this.emitter.addListener(this.eventLabel, eventHandler);\n    return function () {\n        aborted = true;\n        me.emitter.removeListener(me.eventLabel, eventHandler);\n    };\n};\n\n/**\r\n * Publishes an event using `this.emitter` (if `shouldEmit` agrees)\r\n */\nvar trigger = exports.trigger = function trigger() {\n    var args = arguments,\n        pre = this.preEmit.apply(this, args);\n    args = pre === undefined ? args : _.isArguments(pre) ? pre : [].concat(pre);\n    if (this.shouldEmit.apply(this, args)) {\n        this.emitter.emit(this.eventLabel, args);\n    }\n};\n\n/**\r\n * Tries to publish the event on the next tick\r\n */\nvar triggerAsync = exports.triggerAsync = function triggerAsync() {\n    var args = arguments,\n        me = this;\n    _.nextTick(function () {\n        me.trigger.apply(me, args);\n    });\n};\n\n/**\r\n * Wraps the trigger mechanism with a deferral function.\r\n *\r\n * @param {Function} callback the deferral function,\r\n *        first argument is the resolving function and the\r\n *        rest are the arguments provided from the previous\r\n *        trigger invocation\r\n */\nvar deferWith = exports.deferWith = function deferWith(callback) {\n    var oldTrigger = this.trigger,\n        ctx = this,\n        resolver = function resolver() {\n        oldTrigger.apply(ctx, arguments);\n    };\n    this.trigger = function () {\n        callback.apply(ctx, [resolver].concat([].splice.call(arguments, 0)));\n    };\n};"]},"metadata":{},"sourceType":"script"}