{"ast":null,"code":"/* globals React: false */\nvar Reflux = require('reflux-core');\n/**\r\n * Reflux.defineReact function where you can manually supply\r\n * the React object in order to create in case Reflux needs to load before\r\n * React or there is a modular environment where there won't be a global\r\n * React variable.\r\n * @note The third param is for internal usage only.\r\n */\n\n\nvar _react,\n    _defined = false;\n\nfunction defineReact(react, noLongerUsed, extend) {\n  var proto, _extend; // if no Reflux object is yet available then return and just wait until defineReact is called manually with it\n\n\n  try {\n    _react = react || _react || React;\n    _extend = extend || _react.Component;\n  } catch (e) {\n    return;\n  } // if Reflux and React aren't present then ignore, wait until they are properly present\n  // also ignore if it's been called before UNLESS there's manual extending happening\n\n\n  if (!_react || !_extend || _defined && !extend) {\n    return;\n  } // ----------- BEGIN Reflux.Component ------------\n\n  /**\r\n   * Reflux.Component:\r\n   * An implementation for idiomatic React.js classes that mix with\r\n   * Reflux stores. To utilize extend Reflux.Component instead of\r\n   * React.Component. Then you may hook any Reflux store that has a\r\n   * `this.state` property containing its state values to the component\r\n   * via `this.store` or an Array of Reflux stores via `this.stores` in\r\n   * the component's constructor (similar to how you assign initial state\r\n   * in the constructor in ES6 style React). The default values of the\r\n   * stores will automatically reflect in the component's state, and any\r\n   * further `trigger` calls from that store will update properties passed\r\n   * in the trigger into the component automatically.\r\n   */\n\n\n  var RefluxComponent = function (props, context, updater) {\n    _extend.call(this, props, context, updater);\n  }; // equivalent of `extends React.Component` or other class if provided via `extend` param\n\n\n  Reflux.utils.inherits(RefluxComponent, _extend);\n  proto = RefluxComponent.prototype;\n  /**\r\n   * this.storeKeys\r\n   * When this is a falsey value (null by default) the component mixes in\r\n   * all properties from the stores attached to it and updates on changes\r\n   * from all of them. When set to an array of string keys it will only\r\n   * utilized state property names of those keys in any store attached. This\r\n   * lets you choose which parts of stores update the component on a component-\r\n   * by-component basis. If using this it is best set in the constructor.\r\n   */\n\n  proto.storeKeys = null; // on the mounting of the component that is where the store/stores are attached and initialized if needed\n\n  proto.componentWillMount = function () {\n    // if there is a this.store then simply push it onto the this.stores array or make one if needed\n    if (this.store) {\n      if (Array.isArray(this.stores)) {\n        this.stores.unshift(this.store);\n      } else {\n        this.stores = [this.store];\n      }\n    }\n\n    if (this.stores) {\n      this.__storeunsubscribes__ = this.__storeunsubscribes__ || [];\n      var sS = this.setState.bind(this); // this handles the triggering of a store, checking what's updated if proto.storeKeys is utilized\n\n      var onStoreTrigger = function (obj) {\n        var updateObj = filterByStoreKeys(this.storeKeys, obj);\n\n        if (updateObj) {\n          sS(updateObj);\n        }\n      }.bind(this); // for each store in this.stores...\n\n\n      for (var i = 0, ii = this.stores.length; i < ii; i++) {\n        var str = this.stores[i]; // if's a function then we know it's a class getting passed, not an instance\n\n        if (typeof str === 'function') {\n          var storeId = str.id; // if there is NOT a .singleton property on the store then this store has not been initialized yet, so do so\n\n          if (!str.singleton) {\n            str.singleton = new str();\n\n            if (storeId) {\n              Reflux.stores[storeId] = str.singleton;\n            }\n          } // before we weren't sure if we were working with an instance or class, so now we know an instance is created set it\n          // to the variables we were using so that we can just continue on knowing it's the instance we're working with\n\n\n          this.stores[i] = str = str.singleton; // the instance should have an .id property as well if the class does, so set that here\n\n          str.id = storeId; // if there is an id and there is a global state property for this store then merge\n          // the properties from that global state into the default state of the store AND then\n          // set the global state to that new state (since it may have previously been partial)\n\n          if (storeId && Reflux.GlobalState[storeId]) {\n            for (var key in Reflux.GlobalState[storeId]) {\n              str.state[key] = Reflux.GlobalState[storeId][key];\n            }\n\n            Reflux.GlobalState[storeId] = str.state; // otherwise (if it has an id) set the global state to the default state of the store\n          } else if (storeId) {\n            Reflux.GlobalState[storeId] = str.state;\n          } // if no id, then no messing with global state\n\n        } // listen/subscribe for the \".trigger()\" in the store, and track the unsubscribes so that we can unsubscribe on unmount\n\n\n        if (!Reflux.serverMode) {\n          this.__storeunsubscribes__.push(str.listen(onStoreTrigger));\n        } // run set state so that it mixes in the props from the store with the component\n\n\n        var updateObj = filterByStoreKeys(this.storeKeys, str.state);\n\n        if (updateObj) {\n          this.setState(updateObj);\n        }\n      }\n    } // mapStoreToState needs to know if is ready to map or must wait\n\n\n    this.__readytomap__ = true; // if there are mappings that were delayed, do them now\n\n    var dmaps = this.__delayedmaps__;\n\n    if (dmaps) {\n      for (var j = 0, jj = dmaps.length; j < jj; j++) {\n        dmaps[j].func(dmaps[j].state);\n      }\n    }\n\n    this.__delayedmaps__ = null;\n  }; // on the unmount phase of the component unsubscribe that which we subscribed earlier to keep our garbage trail clean\n\n\n  proto.componentWillUnmount = function () {\n    if (this.__storeunsubscribes__) {\n      for (var i = 0, ii = this.__storeunsubscribes__.length; i < ii; i++) {\n        this.__storeunsubscribes__[i]();\n      }\n    }\n\n    this.__readytomap__ = false;\n  };\n  /**\r\n   * this.mapStoreToState\r\n   * This function allow you to supply map the state of a store to the\r\n   * state of this component manually via your own logic. This method\r\n   * is completely separate from this.store/this.stores and/or this.storeKeys.\r\n   * Call this function with an ES6 store (class or singleton instance) as the\r\n   * first argument and your filter function as the second. Your filter function\r\n   * will receive an object of the parts of the ES6 store being updated every\r\n   * time its setState is called. Your filter function then returns an object\r\n   * which will be merged with the component state (IF it has any properties at all,\r\n   * should you return a blank object the component will not rerender).\r\n   */\n\n\n  proto.mapStoreToState = function (store, filterFunc) {\n    // make sure we have a proper singleton instance to work with\n    if (typeof store === 'function') {\n      if (store.singleton) {\n        store = store.singleton;\n      } else {\n        store = Reflux.initStore(store);\n      }\n    } // we need a closure so that the called function can remember the proper filter function to use, so function gets defined here\n\n\n    var self = this;\n\n    function onMapStoreTrigger(obj) {\n      // get an object \n      var update = filterFunc.call(self, obj); // if no object returned from filter functions do nothing\n\n      if (!update) {\n        return;\n      } // check if the update actually has any mapped props\n\n      /*jshint unused: false */\n\n\n      var hasProps = false;\n\n      for (var check in update) {\n        hasProps = true;\n        break;\n      } // if there were props mapped, then update via setState\n\n\n      if (hasProps) {\n        self.setState(update);\n      }\n    } // add the listener to know when the store is triggered\n\n\n    this.__storeunsubscribes__ = this.__storeunsubscribes__ || [];\n\n    this.__storeunsubscribes__.push(store.listen(onMapStoreTrigger)); // now actually run onMapStoreTrigger with the full store state so that we immediately have all store state mapped to component state\n\n\n    if (this.__readytomap__) {\n      onMapStoreTrigger(store.state);\n    } else {\n      this.__delayedmaps__ = this.__delayedmaps__ || [];\n\n      this.__delayedmaps__.push({\n        func: onMapStoreTrigger,\n        state: store.state\n      });\n    }\n  };\n  /**\r\n   * Reflux.Component.extend(OtherClass)\r\n   * This allows you to get classes that extend off of another React.Component\r\n   * inheriting class. For example if you're using a third party that uses\r\n   * components that allow `class MyComponent extends LibComponent` (where LibComponent\r\n   * itself extends React.Component) and you want to use that component with ES6 then\r\n   * you can make a class `var MyDualComponent = Reflux.Component.extend(LibComponent);`\r\n   * then you can use `class MyComponent extends MyDualComponent` to get the benefits\r\n   * of both libraries.\r\n   */\n\n\n  RefluxComponent.extend = function (clss) {\n    return defineReact(null, null, clss);\n  }; // if is being manually called with an `extend` argument present then just return the created class\n\n\n  if (extend) {\n    return RefluxComponent;\n  } // otherwise set as Reflux.Component and continue with other normal definitions\n\n\n  Reflux.Component = RefluxComponent; // also set Reflux.PureComponent (if it exists) using the .extend feature\n\n  if (_react.PureComponent) {\n    Reflux.PureComponent = RefluxComponent.extend(_react.PureComponent);\n  } // ------------ END Reflux.Component ------------\n  // --------- BEGIN Reflux.Store ------------\n\n  /**\r\n   * Reflux.Store:\r\n   * Also implements optional Reflux.Store class that is idiomatic with\r\n   * the React ES6 style. You extend Reflux.Store and then the rest works\r\n   * the same as createStore, except the constructor instead of init, and\r\n   * it holds state in a state property, and a .setState method is available\r\n   * which automatically updates state and does a trigger. Then when using\r\n   * with this.store or this.stores in an ES6 component just plass the class,\r\n   * it will deal with a singleton instantiation of the class automatically.\r\n   */\n\n\n  var RefluxStore = function () {\n    // extending doesn't really work well here, so instead we create an internal instance\n    // and just loop through its properties/methods and make a getter/setter for each\n    // that will actually be getting and setting on that internal instance.\n    this.__store__ = Reflux.createStore();\n    this.state = {};\n    var self = this;\n\n    for (var key in this.__store__) {\n      /*jshint loopfunc: true */\n      (function (prop) {\n        Object.defineProperty(self, prop, {\n          get: function () {\n            return self.__store__[prop];\n          },\n          set: function (v) {\n            self.__store__[prop] = v;\n          }\n        });\n      })(key);\n    }\n  };\n\n  proto = RefluxStore.prototype; // this defines the listenables property, mostly intended to be set as `this.listenables` in the constructor of the store\n  // it is essentially a shortcut to the `listenToMany` method\n\n  Object.defineProperty(proto, \"listenables\", {\n    get: function () {\n      return this.__listenables__;\n    },\n    set: function (v) {\n      var Combined = {};\n\n      if (Array.isArray(v)) {\n        v.forEach(function (obj) {\n          for (var key in obj) {\n            Combined[key] = obj[key];\n          }\n        });\n      } else {\n        Combined = v;\n      }\n\n      this.__listenables__ = Combined;\n      this.listenToMany(Combined);\n    },\n    enumerable: true,\n    configurable: true\n  }); // allows simple usage of `this.setState(obj)` within the store to both update the state and trigger the store to update\n  // components that it is attached to in a simple way that is idiomatic with React\n\n  proto.setState = function (obj) {\n    // Object.assign(this.state, obj); // later turn this to Object.assign and remove loop once support is good enough\n    for (var key in obj) {\n      this.state[key] = obj[key];\n    } // if there's an id (i.e. it's being tracked by the global state) then make sure to update the global state\n\n\n    if (this.id) {\n      Reflux.GlobalState[this.id] = this.state;\n    } // trigger, because any component it's attached to is listening and will merge the store state into its own on a store trigger\n\n\n    this.trigger(obj);\n  }; // this is a static property so that other code can identify that this is a Reflux.Store class\n  // has issues specifically when using babel to transpile your ES6 stores for IE10 and below, not documented and shouldn't use yet\n\n\n  Object.defineProperty(RefluxStore, \"isES6Store\", {\n    get: function () {\n      return true;\n    },\n    enumerable: true,\n    configurable: true\n  }); // allows a shortcut for accessing MyStore.singleton.state as MyStore.state (since common usage makes a singleton)\n\n  Object.defineProperty(RefluxStore, \"state\", {\n    get: function () {\n      if (!this.singleton) {\n        throw new Error('Reflux.Store.state is inaccessible before the store has been initialized.');\n      }\n\n      return this.singleton.state;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /* NOTE:\r\n  If a Reflux.Store definition is given a static id property and used\r\n  properly within a Reflux.Component or with Reflux.initStore then\r\n  it will be added to the Reflux.GlobalState object which automatically tracks the\r\n  current state of all such defined stores in the program. */\n\n  Reflux.Store = RefluxStore; // ----------- END Reflux.Store -------------\n  // --------- BEGIN Reflux Static Props/Methods ------------\n\n  /**\r\n   * Reflux.GlobalState is where data is stored for any Reflux.Store that has a static id property. Each store's\r\n   * state will be on the Reflux.GlobalState object with the id as the key. So a store with the id \"MyStore\" and\r\n   * a state {\"color\":\"red\"} will end up with a Reflux.GlobalState of {\"MyStore\":{\"color\":\"red\"}}\r\n   * Reflux.GlobalState is an accessible part of the API. However, keep in mind that non-primitive properties you\r\n   * read off of it will continue to mutate and you can only manually mutate Reflux.GlobalState BEFORE any component\r\n   * mounting of components with ES6 stores. For more functionality look to Reflux.setGlobalState to change the global\r\n   * state at any point, and Reflux.getGlobalState to return a deep clone of the Reflux.GlobalState object which will\r\n   * not continue to mutate as Reflux.GlobalState continues to mutate.\r\n   */\n\n  Reflux.GlobalState = Reflux.GlobalState || {};\n  /**\r\n   * Reflux.stores\r\n   * All initialized stores that have an id will have a reference to their singleton stored here with the key being the id.\r\n   */\n\n  Reflux.stores = {};\n  /**\r\n   * Reflux.getGlobalState takes no arguments, and returns a deep clone of Reflux.GlobalState \r\n   * which will not continue to mutate as Reflux.GlobalState does. It can essentially store\r\n   * snapshots of the global state as the program goes for saving or for in-app time travel.\r\n   */\n\n  Reflux.getGlobalState = function () {\n    return clone(Reflux.GlobalState);\n  };\n  /**\r\n   * Reflux.setGlobalState takes one argument that is a representation of the a possible\r\n   * global state. It updates all stores in the program to represent data in that given state.\r\n   * This includes triggering those stores so that that state is represented in any Reflux.Component\r\n   * instances they are attached to. Partial states may be given to it, and only the represented\r\n   * stores/state values will be updated.\r\n   */\n\n\n  Reflux.setGlobalState = function (obj) {\n    for (var storeID in obj) {\n      if (Reflux.stores[storeID]) {\n        Reflux.stores[storeID].setState(obj[storeID]);\n      } else {\n        Reflux.GlobalState[storeID] = obj[storeID];\n      }\n    }\n  };\n  /**\r\n   * Reflux.initStore takes one argument (a class that extends Reflux.Store) and returns a singleton\r\n   * intance of that class. Its main functionality is to be able to mimic what happens to stores attached to\r\n   * this.store or this.stores during the mounting phase of a component without having to actually attach the\r\n   * store to a component in order to work properly with the global state.\r\n   */\n  // Reflux.initializeGlobalStore is kept for backwards compatibility, but deprecated since the function is\n  // now for more broad instantiation of globally stored AND non-globally stored classes\n\n\n  Reflux.initializeGlobalStore = Reflux.initStore = function (str) {\n    var storeId = str.id; // if they're initializing something twice then we're done already, return it\n\n    if (str.singleton) {\n      return str.singleton;\n    } // if no id then it's easy: just make new instance and set to singleton\n\n\n    if (!storeId) {\n      str.singleton = new str();\n      return str.singleton;\n    } // create the singleton and assign it to the class's singleton static property\n\n\n    var inst = str.singleton = new str(); // store it on the Reflux.stores array to be accessible later\n\n    Reflux.stores[storeId] = inst; // the singleton instance itself should also have the id property of the class\n\n    inst.id = storeId; // if the global state has something set for this id, copy it to the state and then\n    // make sure to set the global state to the end result, since it may have only been partial\n\n    if (Reflux.GlobalState[storeId]) {\n      for (var key in Reflux.GlobalState[storeId]) {\n        inst.state[key] = Reflux.GlobalState[storeId][key];\n      }\n\n      Reflux.GlobalState[storeId] = inst.state; // otherwise just set the global state to the default state of the class\n    } else {\n      Reflux.GlobalState[storeId] = inst.state;\n    } // returns the singleton itself, though it will also be accessible as as `MyClass.singleton`\n\n\n    return inst;\n  }; // --------- END Reflux Static Props/Methods ------------\n  // so it knows not to redefine Reflux static stuff and stores if called again\n\n\n  _defined = true;\n} // filters a state object by storeKeys array (if it exists)\n// if filtering and obj contains no properties to use, returns false to let the component know not to update\n\n\nfunction filterByStoreKeys(storeKeys, obj) {\n  // if there are not storeKeys defined then simply return the whole original object\n  if (!storeKeys) {\n    return obj;\n  } // otherwise go through and only update properties that are in the storeKeys array, and return straight false if there are none\n\n\n  var doUpdate = false;\n  var updateObj = {};\n\n  for (var i = 0, ii = storeKeys.length; i < ii; i++) {\n    var prop = storeKeys[i];\n\n    if (obj.hasOwnProperty(prop)) {\n      doUpdate = true;\n      updateObj[prop] = obj[prop];\n    }\n  }\n\n  return doUpdate ? updateObj : false;\n} // this is utilized by some of the global state functionality in order to get a clone that will\n// not continue to be modified as the GlobalState mutates\n\n\nfunction clone(frm, to) {\n  if (frm === null || typeof frm !== \"object\") {\n    return frm;\n  }\n\n  if (frm.constructor !== Object && frm.constructor !== Array) {\n    return frm;\n  }\n\n  if (frm.constructor === Date || frm.constructor === RegExp || frm.constructor === Function || frm.constructor === String || frm.constructor === Number || frm.constructor === Boolean) {\n    return new frm.constructor(frm);\n  }\n\n  to = to || new frm.constructor();\n\n  for (var name in frm) {\n    to[name] = typeof to[name] === \"undefined\" ? clone(frm[name], null) : to[name];\n  }\n\n  return to;\n}\n\nmodule.exports = defineReact;","map":{"version":3,"sources":["/home/tudor/work/sd/assignment-2-Lolkekzor/project/frontend/node_modules/reflux/src/defineReact.js"],"names":["Reflux","require","_react","_defined","defineReact","react","noLongerUsed","extend","proto","_extend","React","Component","e","RefluxComponent","props","context","updater","call","utils","inherits","prototype","storeKeys","componentWillMount","store","Array","isArray","stores","unshift","__storeunsubscribes__","sS","setState","bind","onStoreTrigger","obj","updateObj","filterByStoreKeys","i","ii","length","str","storeId","id","singleton","GlobalState","key","state","serverMode","push","listen","__readytomap__","dmaps","__delayedmaps__","j","jj","func","componentWillUnmount","mapStoreToState","filterFunc","initStore","self","onMapStoreTrigger","update","hasProps","check","clss","PureComponent","RefluxStore","__store__","createStore","prop","Object","defineProperty","get","set","v","__listenables__","Combined","forEach","listenToMany","enumerable","configurable","trigger","Error","Store","getGlobalState","clone","setGlobalState","storeID","initializeGlobalStore","inst","doUpdate","hasOwnProperty","frm","to","constructor","Date","RegExp","Function","String","Number","Boolean","name","module","exports"],"mappings":"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","sourcesContent":["/* globals React: false */\r\n\r\nvar Reflux = require('reflux-core');\r\n\r\n/**\r\n * Reflux.defineReact function where you can manually supply\r\n * the React object in order to create in case Reflux needs to load before\r\n * React or there is a modular environment where there won't be a global\r\n * React variable.\r\n * @note The third param is for internal usage only.\r\n */\r\nvar _react, _defined = false;\r\nfunction defineReact(react, noLongerUsed, extend)\r\n{\r\n\tvar proto, _extend;\r\n\t\r\n\t// if no Reflux object is yet available then return and just wait until defineReact is called manually with it\r\n\ttry {\r\n\t\t_react  = react  || _react  || React;\r\n\t\t_extend = extend || _react.Component;\r\n\t} catch (e) {\r\n\t\treturn;\r\n\t}\r\n\t\r\n\t// if Reflux and React aren't present then ignore, wait until they are properly present\r\n\t// also ignore if it's been called before UNLESS there's manual extending happening\r\n\tif (!_react || !_extend || (_defined && !extend)) {\r\n\t\treturn;\r\n\t}\r\n\t\r\n\t// ----------- BEGIN Reflux.Component ------------\r\n\t/**\r\n\t * Reflux.Component:\r\n\t * An implementation for idiomatic React.js classes that mix with\r\n\t * Reflux stores. To utilize extend Reflux.Component instead of\r\n\t * React.Component. Then you may hook any Reflux store that has a\r\n\t * `this.state` property containing its state values to the component\r\n\t * via `this.store` or an Array of Reflux stores via `this.stores` in\r\n\t * the component's constructor (similar to how you assign initial state\r\n\t * in the constructor in ES6 style React). The default values of the\r\n\t * stores will automatically reflect in the component's state, and any\r\n\t * further `trigger` calls from that store will update properties passed\r\n\t * in the trigger into the component automatically.\r\n\t */\r\n\tvar RefluxComponent = function(props, context, updater) {\r\n\t\t_extend.call(this, props, context, updater);\r\n\t};\r\n\t\r\n\t// equivalent of `extends React.Component` or other class if provided via `extend` param\r\n\tReflux.utils.inherits(RefluxComponent, _extend);\r\n\t\r\n\tproto = RefluxComponent.prototype;\r\n\t\r\n\t/**\r\n\t * this.storeKeys\r\n\t * When this is a falsey value (null by default) the component mixes in\r\n\t * all properties from the stores attached to it and updates on changes\r\n\t * from all of them. When set to an array of string keys it will only\r\n\t * utilized state property names of those keys in any store attached. This\r\n\t * lets you choose which parts of stores update the component on a component-\r\n\t * by-component basis. If using this it is best set in the constructor.\r\n\t */\r\n\tproto.storeKeys = null;\r\n\t\r\n\t// on the mounting of the component that is where the store/stores are attached and initialized if needed\r\n\tproto.componentWillMount = function () {\r\n\t\t// if there is a this.store then simply push it onto the this.stores array or make one if needed\r\n\t\tif (this.store) {\r\n\t\t\tif (Array.isArray(this.stores)) {\r\n\t\t\t\tthis.stores.unshift(this.store);\r\n\t\t\t} else {\r\n\t\t\t\tthis.stores = [this.store];\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\tif (this.stores) {\r\n\t\t\tthis.__storeunsubscribes__ = this.__storeunsubscribes__ || [];\r\n\t\t\tvar sS = this.setState.bind(this);\r\n\t\t\t// this handles the triggering of a store, checking what's updated if proto.storeKeys is utilized\r\n\t\t\tvar onStoreTrigger = function(obj){\r\n\t\t\t\tvar updateObj = filterByStoreKeys(this.storeKeys, obj);\r\n\t\t\t\tif (updateObj) {\r\n\t\t\t\t\tsS(updateObj);\r\n\t\t\t\t}\r\n\t\t\t}.bind(this);\r\n\t\t\t// for each store in this.stores...\r\n\t\t\tfor (var i = 0, ii = this.stores.length; i < ii; i++) {\r\n\t\t\t\tvar str = this.stores[i];\r\n\t\t\t\t// if's a function then we know it's a class getting passed, not an instance\r\n\t\t\t\tif (typeof str === 'function') {\r\n\t\t\t\t\tvar storeId = str.id;\r\n\t\t\t\t\t// if there is NOT a .singleton property on the store then this store has not been initialized yet, so do so\r\n\t\t\t\t\tif (!str.singleton) {\r\n\t\t\t\t\t\tstr.singleton = new str();\r\n\t\t\t\t\t\tif (storeId) {\r\n\t\t\t\t\t\t\tReflux.stores[storeId] = str.singleton;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\t// before we weren't sure if we were working with an instance or class, so now we know an instance is created set it\r\n\t\t\t\t\t// to the variables we were using so that we can just continue on knowing it's the instance we're working with\r\n\t\t\t\t\tthis.stores[i] = str = str.singleton;\r\n\t\t\t\t\t// the instance should have an .id property as well if the class does, so set that here\r\n\t\t\t\t\tstr.id = storeId;\r\n\t\t\t\t\t// if there is an id and there is a global state property for this store then merge\r\n\t\t\t\t\t// the properties from that global state into the default state of the store AND then\r\n\t\t\t\t\t// set the global state to that new state (since it may have previously been partial)\r\n\t\t\t\t\tif (storeId && Reflux.GlobalState[storeId]) {\r\n\t\t\t\t\t\tfor (var key in Reflux.GlobalState[storeId]) {\r\n\t\t\t\t\t\t\tstr.state[key] = Reflux.GlobalState[storeId][key];\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tReflux.GlobalState[storeId] = str.state;\r\n\t\t\t\t\t// otherwise (if it has an id) set the global state to the default state of the store\r\n\t\t\t\t\t} else if (storeId) {\r\n\t\t\t\t\t\tReflux.GlobalState[storeId] = str.state;\r\n\t\t\t\t\t}\r\n\t\t\t\t\t// if no id, then no messing with global state\r\n\t\t\t\t}\r\n\t\t\t\t// listen/subscribe for the \".trigger()\" in the store, and track the unsubscribes so that we can unsubscribe on unmount\r\n\t\t\t\tif (!Reflux.serverMode) {\r\n\t\t\t\t\tthis.__storeunsubscribes__.push(str.listen(onStoreTrigger));\r\n\t\t\t\t}\r\n\t\t\t\t// run set state so that it mixes in the props from the store with the component\r\n\t\t\t\tvar updateObj = filterByStoreKeys(this.storeKeys, str.state);\r\n\t\t\t\tif (updateObj) {\r\n\t\t\t\t\tthis.setState(updateObj);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\t// mapStoreToState needs to know if is ready to map or must wait\r\n\t\tthis.__readytomap__ = true;\r\n\t\t// if there are mappings that were delayed, do them now\r\n\t\tvar dmaps = this.__delayedmaps__;\r\n\t\tif (dmaps) {\r\n\t\t\tfor (var j=0,jj=dmaps.length; j<jj; j++) {\r\n\t\t\t\tdmaps[j].func( dmaps[j].state );\r\n\t\t\t}\r\n\t\t}\r\n\t\tthis.__delayedmaps__ = null;\r\n\t};\r\n\t\r\n\t// on the unmount phase of the component unsubscribe that which we subscribed earlier to keep our garbage trail clean\r\n\tproto.componentWillUnmount = function () {\r\n\t\tif (this.__storeunsubscribes__) {\r\n\t\t\tfor (var i = 0, ii = this.__storeunsubscribes__.length; i < ii; i++) {\r\n\t\t\t\tthis.__storeunsubscribes__[i]();\r\n\t\t\t}\r\n\t\t}\r\n\t\tthis.__readytomap__ = false;\r\n\t};\r\n\t\r\n\t/**\r\n\t * this.mapStoreToState\r\n\t * This function allow you to supply map the state of a store to the\r\n\t * state of this component manually via your own logic. This method\r\n\t * is completely separate from this.store/this.stores and/or this.storeKeys.\r\n\t * Call this function with an ES6 store (class or singleton instance) as the\r\n\t * first argument and your filter function as the second. Your filter function\r\n\t * will receive an object of the parts of the ES6 store being updated every\r\n\t * time its setState is called. Your filter function then returns an object\r\n\t * which will be merged with the component state (IF it has any properties at all,\r\n\t * should you return a blank object the component will not rerender).\r\n\t */\r\n\tproto.mapStoreToState = function(store, filterFunc)\r\n\t{\r\n\t\t// make sure we have a proper singleton instance to work with\r\n\t\tif (typeof store === 'function') {\r\n\t\t\tif (store.singleton) {\r\n\t\t\t\tstore = store.singleton;\r\n\t\t\t} else {\r\n\t\t\t\tstore = Reflux.initStore(store);\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\t// we need a closure so that the called function can remember the proper filter function to use, so function gets defined here\r\n\t\tvar self = this;\r\n\t\tfunction onMapStoreTrigger(obj) {\r\n\t\t\t// get an object \r\n\t\t\tvar update = filterFunc.call(self, obj);\r\n\t\t\t// if no object returned from filter functions do nothing\r\n\t\t\tif (!update) {\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t\t// check if the update actually has any mapped props\r\n\t\t\t/*jshint unused: false */\r\n\t\t\tvar hasProps = false;\r\n\t\t\tfor (var check in update) {\r\n\t\t\t\thasProps = true;\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t\t// if there were props mapped, then update via setState\r\n\t\t\tif (hasProps) {\r\n\t\t\t\tself.setState(update);\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\t// add the listener to know when the store is triggered\r\n\t\tthis.__storeunsubscribes__ = this.__storeunsubscribes__ || [];\r\n\t\tthis.__storeunsubscribes__.push(store.listen(onMapStoreTrigger));\r\n\t\t\r\n\t\t// now actually run onMapStoreTrigger with the full store state so that we immediately have all store state mapped to component state\r\n\t\tif (this.__readytomap__) {\r\n\t\t\tonMapStoreTrigger(store.state);\r\n\t\t} else {\r\n\t\t\tthis.__delayedmaps__ = this.__delayedmaps__ || [];\r\n\t\t\tthis.__delayedmaps__.push({func:onMapStoreTrigger, state:store.state});\r\n\t\t}\r\n\t};\r\n\t\r\n\t/**\r\n\t * Reflux.Component.extend(OtherClass)\r\n\t * This allows you to get classes that extend off of another React.Component\r\n\t * inheriting class. For example if you're using a third party that uses\r\n\t * components that allow `class MyComponent extends LibComponent` (where LibComponent\r\n\t * itself extends React.Component) and you want to use that component with ES6 then\r\n\t * you can make a class `var MyDualComponent = Reflux.Component.extend(LibComponent);`\r\n\t * then you can use `class MyComponent extends MyDualComponent` to get the benefits\r\n\t * of both libraries.\r\n\t */\r\n\tRefluxComponent.extend = function(clss) {\r\n\t\treturn defineReact(null, null, clss);\r\n\t};\r\n\t\r\n\t// if is being manually called with an `extend` argument present then just return the created class\r\n\tif (extend) {\r\n\t\treturn RefluxComponent;\r\n\t}\r\n\t\r\n\t// otherwise set as Reflux.Component and continue with other normal definitions\r\n\tReflux.Component = RefluxComponent;\r\n\t\r\n\t// also set Reflux.PureComponent (if it exists) using the .extend feature\r\n\tif (_react.PureComponent) {\r\n\t\tReflux.PureComponent = RefluxComponent.extend(_react.PureComponent);\r\n\t}\r\n\t\r\n\t// ------------ END Reflux.Component ------------\r\n\t\r\n\t// --------- BEGIN Reflux.Store ------------\r\n\t/**\r\n\t * Reflux.Store:\r\n\t * Also implements optional Reflux.Store class that is idiomatic with\r\n\t * the React ES6 style. You extend Reflux.Store and then the rest works\r\n\t * the same as createStore, except the constructor instead of init, and\r\n\t * it holds state in a state property, and a .setState method is available\r\n\t * which automatically updates state and does a trigger. Then when using\r\n\t * with this.store or this.stores in an ES6 component just plass the class,\r\n\t * it will deal with a singleton instantiation of the class automatically.\r\n\t */\r\n\tvar RefluxStore = function() {\r\n\t\t// extending doesn't really work well here, so instead we create an internal instance\r\n\t\t// and just loop through its properties/methods and make a getter/setter for each\r\n\t\t// that will actually be getting and setting on that internal instance.\r\n\t\tthis.__store__ = Reflux.createStore();\r\n\t\tthis.state = {};\r\n\t\tvar self = this;\r\n\t\tfor (var key in this.__store__) {\r\n\t\t\t/*jshint loopfunc: true */\r\n\t\t\t(function (prop) {\r\n\t\t\t\tObject.defineProperty(self, prop, {\r\n\t\t\t\t\tget: function () { return self.__store__[prop]; },\r\n\t\t\t\t\tset: function (v) { self.__store__[prop] = v; }\r\n\t\t\t\t});\r\n\t\t\t})(key);\r\n\t\t}\r\n\t};\r\n\t\r\n\tproto = RefluxStore.prototype;\r\n\t\r\n\t// this defines the listenables property, mostly intended to be set as `this.listenables` in the constructor of the store\r\n\t// it is essentially a shortcut to the `listenToMany` method\r\n\tObject.defineProperty(proto, \"listenables\", {\r\n\t\tget: function () {\r\n\t\t\treturn this.__listenables__;\r\n\t\t},\r\n\t\tset: function (v) {\r\n\t\t\tvar Combined = {};\r\n\t\t\tif (Array.isArray(v)){\r\n\t\t\t\tv.forEach(function(obj) {\r\n\t\t\t\t\tfor (var key in obj) {\r\n\t\t\t\t\t\tCombined[key] = obj[key];\r\n\t\t\t\t\t}\r\n\t\t\t\t});\r\n\t\t\t} else {\r\n\t\t\t\tCombined = v;\r\n\t\t\t}\r\n\t\t\tthis.__listenables__ = Combined;\r\n\t\t\tthis.listenToMany(Combined);\r\n\t\t},\r\n\t\tenumerable: true,\r\n\t\tconfigurable: true\r\n\t});\r\n\t\r\n\t// allows simple usage of `this.setState(obj)` within the store to both update the state and trigger the store to update\r\n\t// components that it is attached to in a simple way that is idiomatic with React\r\n\tproto.setState = function (obj) {\r\n\t\t// Object.assign(this.state, obj); // later turn this to Object.assign and remove loop once support is good enough\r\n\t\tfor (var key in obj) {\r\n\t\t\tthis.state[key] = obj[key];\r\n\t\t}\r\n\t\t// if there's an id (i.e. it's being tracked by the global state) then make sure to update the global state\r\n\t\tif (this.id) {\r\n\t\t\tReflux.GlobalState[this.id] = this.state;\r\n\t\t}\r\n\t\t// trigger, because any component it's attached to is listening and will merge the store state into its own on a store trigger\r\n\t\tthis.trigger(obj);\r\n\t};\r\n\t\r\n\t// this is a static property so that other code can identify that this is a Reflux.Store class\r\n\t// has issues specifically when using babel to transpile your ES6 stores for IE10 and below, not documented and shouldn't use yet\r\n\tObject.defineProperty(RefluxStore, \"isES6Store\", {\r\n\t\tget: function () {\r\n\t\t\treturn true;\r\n\t\t},\r\n\t\tenumerable: true,\r\n\t\tconfigurable: true\r\n\t});\r\n\t\r\n\t// allows a shortcut for accessing MyStore.singleton.state as MyStore.state (since common usage makes a singleton)\r\n\tObject.defineProperty(RefluxStore, \"state\", {\r\n\t\tget: function () {\r\n\t\t\tif (!this.singleton) {\r\n\t\t\t\tthrow new Error('Reflux.Store.state is inaccessible before the store has been initialized.');\r\n\t\t\t}\r\n\t\t\treturn this.singleton.state;\r\n\t\t},\r\n\t\tenumerable: true,\r\n\t\tconfigurable: true\r\n\t});\r\n\t\r\n\t/* NOTE:\r\n\tIf a Reflux.Store definition is given a static id property and used\r\n\tproperly within a Reflux.Component or with Reflux.initStore then\r\n\tit will be added to the Reflux.GlobalState object which automatically tracks the\r\n\tcurrent state of all such defined stores in the program. */\r\n\t\r\n\tReflux.Store = RefluxStore;\r\n\t// ----------- END Reflux.Store -------------\r\n\t\r\n\t// --------- BEGIN Reflux Static Props/Methods ------------\r\n\t/**\r\n\t * Reflux.GlobalState is where data is stored for any Reflux.Store that has a static id property. Each store's\r\n\t * state will be on the Reflux.GlobalState object with the id as the key. So a store with the id \"MyStore\" and\r\n\t * a state {\"color\":\"red\"} will end up with a Reflux.GlobalState of {\"MyStore\":{\"color\":\"red\"}}\r\n\t * Reflux.GlobalState is an accessible part of the API. However, keep in mind that non-primitive properties you\r\n\t * read off of it will continue to mutate and you can only manually mutate Reflux.GlobalState BEFORE any component\r\n\t * mounting of components with ES6 stores. For more functionality look to Reflux.setGlobalState to change the global\r\n\t * state at any point, and Reflux.getGlobalState to return a deep clone of the Reflux.GlobalState object which will\r\n\t * not continue to mutate as Reflux.GlobalState continues to mutate.\r\n\t */\r\n\tReflux.GlobalState = Reflux.GlobalState || {};\r\n\t\r\n\t/**\r\n\t * Reflux.stores\r\n\t * All initialized stores that have an id will have a reference to their singleton stored here with the key being the id.\r\n\t */\r\n\tReflux.stores = {};\r\n\t\r\n\t/**\r\n\t * Reflux.getGlobalState takes no arguments, and returns a deep clone of Reflux.GlobalState \r\n\t * which will not continue to mutate as Reflux.GlobalState does. It can essentially store\r\n\t * snapshots of the global state as the program goes for saving or for in-app time travel.\r\n\t */\r\n\tReflux.getGlobalState = function() {\r\n\t\treturn clone(Reflux.GlobalState);\r\n\t};\r\n\t\r\n\t/**\r\n\t * Reflux.setGlobalState takes one argument that is a representation of the a possible\r\n\t * global state. It updates all stores in the program to represent data in that given state.\r\n\t * This includes triggering those stores so that that state is represented in any Reflux.Component\r\n\t * instances they are attached to. Partial states may be given to it, and only the represented\r\n\t * stores/state values will be updated.\r\n\t */\r\n\tReflux.setGlobalState = function(obj) {\r\n\t\tfor (var storeID in obj) {\r\n\t\t\tif (Reflux.stores[storeID]) {\r\n\t\t\t\tReflux.stores[storeID].setState(obj[storeID]);\r\n\t\t\t} else {\r\n\t\t\t\tReflux.GlobalState[storeID] = obj[storeID];\r\n\t\t\t}\r\n\t\t}\r\n\t};\r\n\t\r\n\t/**\r\n\t * Reflux.initStore takes one argument (a class that extends Reflux.Store) and returns a singleton\r\n\t * intance of that class. Its main functionality is to be able to mimic what happens to stores attached to\r\n\t * this.store or this.stores during the mounting phase of a component without having to actually attach the\r\n\t * store to a component in order to work properly with the global state.\r\n\t */\r\n\t// Reflux.initializeGlobalStore is kept for backwards compatibility, but deprecated since the function is\r\n\t// now for more broad instantiation of globally stored AND non-globally stored classes\r\n\tReflux.initializeGlobalStore = Reflux.initStore = function(str) {\r\n\t\tvar storeId = str.id;\r\n\t\t// if they're initializing something twice then we're done already, return it\r\n\t\tif (str.singleton) {\r\n\t\t\treturn str.singleton;\r\n\t\t}\r\n\t\t// if no id then it's easy: just make new instance and set to singleton\r\n\t\tif (!storeId) {\r\n\t\t\tstr.singleton = new str();\r\n\t\t\treturn str.singleton;\r\n\t\t}\r\n\t\t// create the singleton and assign it to the class's singleton static property\r\n\t\tvar inst = str.singleton = new str();\r\n\t\t// store it on the Reflux.stores array to be accessible later\r\n\t\tReflux.stores[storeId] = inst;\r\n\t\t// the singleton instance itself should also have the id property of the class\r\n\t\tinst.id = storeId;\r\n\t\t// if the global state has something set for this id, copy it to the state and then\r\n\t\t// make sure to set the global state to the end result, since it may have only been partial\r\n\t\tif (Reflux.GlobalState[storeId]) {\r\n\t\t\tfor (var key in Reflux.GlobalState[storeId]) {\r\n\t\t\t\tinst.state[key] = Reflux.GlobalState[storeId][key];\r\n\t\t\t}\r\n\t\t\tReflux.GlobalState[storeId] = inst.state;\r\n\t\t// otherwise just set the global state to the default state of the class\r\n\t\t} else {\r\n\t\t\tReflux.GlobalState[storeId] = inst.state;\r\n\t\t}\r\n\t\t// returns the singleton itself, though it will also be accessible as as `MyClass.singleton`\r\n\t\treturn inst;\r\n\t};\r\n\t// --------- END Reflux Static Props/Methods ------------\r\n\t\r\n\t// so it knows not to redefine Reflux static stuff and stores if called again\r\n\t_defined = true;\r\n}\r\n\r\n// filters a state object by storeKeys array (if it exists)\r\n// if filtering and obj contains no properties to use, returns false to let the component know not to update\r\nfunction filterByStoreKeys(storeKeys, obj)\r\n{\r\n\t// if there are not storeKeys defined then simply return the whole original object\r\n\tif (!storeKeys) {\r\n\t\treturn obj;\r\n\t}\r\n\t// otherwise go through and only update properties that are in the storeKeys array, and return straight false if there are none\r\n\tvar doUpdate = false;\r\n\tvar updateObj = {};\r\n\tfor (var i = 0, ii = storeKeys.length; i < ii; i++) {\r\n\t\tvar prop = storeKeys[i];\r\n\t\tif (obj.hasOwnProperty(prop)) {\r\n\t\t\tdoUpdate = true;\r\n\t\t\tupdateObj[prop] = obj[prop];\r\n\t\t}\r\n\t}\r\n\treturn doUpdate ? updateObj : false;\r\n}\r\n\r\n// this is utilized by some of the global state functionality in order to get a clone that will\r\n// not continue to be modified as the GlobalState mutates\r\nfunction clone(frm, to) {\r\n\tif (frm === null || typeof frm !== \"object\") {\r\n\t\treturn frm;\r\n\t}\r\n\tif (frm.constructor !== Object && frm.constructor !== Array) {\r\n\t\treturn frm;\r\n\t}\r\n\tif (frm.constructor === Date || frm.constructor === RegExp || frm.constructor === Function ||\r\n\t\tfrm.constructor === String || frm.constructor === Number || frm.constructor === Boolean) {\r\n\t\treturn new frm.constructor(frm);\r\n\t}\r\n\tto = to || new frm.constructor();\r\n\tfor (var name in frm) {\r\n\t\tto[name] = typeof to[name] === \"undefined\" ? clone(frm[name], null) : to[name];\r\n\t}\r\n\treturn to;\r\n}\r\n\r\nmodule.exports = defineReact;\r\n\r\n"]},"metadata":{},"sourceType":"script"}