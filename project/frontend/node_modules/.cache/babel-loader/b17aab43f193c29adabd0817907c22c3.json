{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.createAction = createAction;\n\nvar _utils = require(\"./utils\");\n\nvar _ = _interopRequireWildcard(_utils);\n\nvar _ActionMethods = require(\"./ActionMethods\");\n\nvar ActionMethods = _interopRequireWildcard(_ActionMethods);\n\nvar _PublisherMethods = require(\"./PublisherMethods\");\n\nvar PublisherMethods = _interopRequireWildcard(_PublisherMethods);\n\nvar _Keep = require(\"./Keep\");\n\nvar Keep = _interopRequireWildcard(_Keep);\n\nfunction _interopRequireWildcard(obj) {\n  if (obj && obj.__esModule) {\n    return obj;\n  } else {\n    var newObj = {};\n\n    if (obj != null) {\n      for (var key in obj) {\n        if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];\n      }\n    }\n\n    newObj.default = obj;\n    return newObj;\n  }\n}\n\nvar allowed = {\n  preEmit: 1,\n  shouldEmit: 1\n};\n/**\r\n * Creates an action functor object. It is mixed in with functions\r\n * from the `PublisherMethods` mixin. `preEmit` and `shouldEmit` may\r\n * be overridden in the definition object.\r\n *\r\n * @param {Object} definition The action object definition\r\n */\n\nfunction createAction(definition) {\n  definition = definition || {};\n\n  if (!_.isObject(definition)) {\n    definition = {\n      actionName: definition\n    };\n  }\n\n  for (var a in ActionMethods) {\n    if (!allowed[a] && PublisherMethods[a]) {\n      throw new Error(\"Cannot override API method \" + a + \" in Reflux.ActionMethods. Use another method name or override it on Reflux.PublisherMethods instead.\");\n    }\n  }\n\n  for (var d in definition) {\n    if (!allowed[d] && PublisherMethods[d]) {\n      throw new Error(\"Cannot override API method \" + d + \" in action creation. Use another method name or override it on Reflux.PublisherMethods instead.\");\n    }\n  }\n\n  definition.children = definition.children || [];\n\n  if (definition.asyncResult) {\n    definition.children = definition.children.concat([\"completed\", \"failed\"]);\n  }\n\n  var i = 0,\n      childActions = {};\n\n  for (; i < definition.children.length; i++) {\n    var chDef = definition.children[i];\n    var chName = typeof chDef === \"string\" ? chDef : chDef.actionName;\n    childActions[chName] = createAction(chDef);\n  }\n\n  var context = _.extend({\n    eventLabel: \"action\",\n    emitter: new _.EventEmitter(),\n    _isAction: true\n  }, PublisherMethods, ActionMethods, definition);\n\n  var functor = function functor() {\n    var hasChildActions = false;\n    /* eslint no-unused-vars:0 */\n\n    for (var ignore in functor.childActions) {\n      hasChildActions = true;\n      break;\n    }\n\n    var async = !functor.sync && typeof functor.sync !== \"undefined\" || hasChildActions;\n    var triggerType = async ? \"triggerAsync\" : \"trigger\";\n    return functor[triggerType].apply(functor, arguments);\n  };\n\n  _.extend(functor, childActions, context);\n\n  Keep.addAction(functor);\n  return functor;\n}","map":{"version":3,"sources":["/home/tudor/work/sd/assignment-3-Lolkekzor/project/frontend/node_modules/reflux-core/lib/createAction.js"],"names":["Object","defineProperty","exports","value","createAction","_utils","require","_","_interopRequireWildcard","_ActionMethods","ActionMethods","_PublisherMethods","PublisherMethods","_Keep","Keep","obj","__esModule","newObj","key","prototype","hasOwnProperty","call","default","allowed","preEmit","shouldEmit","definition","isObject","actionName","a","Error","d","children","asyncResult","concat","i","childActions","length","chDef","chName","context","extend","eventLabel","emitter","EventEmitter","_isAction","functor","hasChildActions","ignore","async","sync","triggerType","apply","arguments","addAction"],"mappings":"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","sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.createAction = createAction;\n\nvar _utils = require(\"./utils\");\n\nvar _ = _interopRequireWildcard(_utils);\n\nvar _ActionMethods = require(\"./ActionMethods\");\n\nvar ActionMethods = _interopRequireWildcard(_ActionMethods);\n\nvar _PublisherMethods = require(\"./PublisherMethods\");\n\nvar PublisherMethods = _interopRequireWildcard(_PublisherMethods);\n\nvar _Keep = require(\"./Keep\");\n\nvar Keep = _interopRequireWildcard(_Keep);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nvar allowed = { preEmit: 1, shouldEmit: 1 };\n\n/**\r\n * Creates an action functor object. It is mixed in with functions\r\n * from the `PublisherMethods` mixin. `preEmit` and `shouldEmit` may\r\n * be overridden in the definition object.\r\n *\r\n * @param {Object} definition The action object definition\r\n */\nfunction createAction(definition) {\n\n    definition = definition || {};\n    if (!_.isObject(definition)) {\n        definition = { actionName: definition };\n    }\n\n    for (var a in ActionMethods) {\n        if (!allowed[a] && PublisherMethods[a]) {\n            throw new Error(\"Cannot override API method \" + a + \" in Reflux.ActionMethods. Use another method name or override it on Reflux.PublisherMethods instead.\");\n        }\n    }\n\n    for (var d in definition) {\n        if (!allowed[d] && PublisherMethods[d]) {\n            throw new Error(\"Cannot override API method \" + d + \" in action creation. Use another method name or override it on Reflux.PublisherMethods instead.\");\n        }\n    }\n\n    definition.children = definition.children || [];\n    if (definition.asyncResult) {\n        definition.children = definition.children.concat([\"completed\", \"failed\"]);\n    }\n\n    var i = 0,\n        childActions = {};\n    for (; i < definition.children.length; i++) {\n        var chDef = definition.children[i];\n        var chName = typeof chDef === \"string\" ? chDef : chDef.actionName;\n        childActions[chName] = createAction(chDef);\n    }\n\n    var context = _.extend({\n        eventLabel: \"action\",\n        emitter: new _.EventEmitter(),\n        _isAction: true\n    }, PublisherMethods, ActionMethods, definition);\n\n    var functor = function functor() {\n        var hasChildActions = false;\n        /* eslint no-unused-vars:0 */\n        for (var ignore in functor.childActions) {\n            hasChildActions = true;break;\n        }\n        var async = !functor.sync && typeof functor.sync !== \"undefined\" || hasChildActions;\n        var triggerType = async ? \"triggerAsync\" : \"trigger\";\n        return functor[triggerType].apply(functor, arguments);\n    };\n\n    _.extend(functor, childActions, context);\n\n    Keep.addAction(functor);\n\n    return functor;\n}"]},"metadata":{},"sourceType":"script"}