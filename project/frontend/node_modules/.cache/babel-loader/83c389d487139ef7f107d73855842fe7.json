{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.joinStrict = exports.joinConcat = exports.joinLeading = exports.joinTrailing = exports.fetchInitialState = exports.stopListeningToAll = exports.stopListeningTo = exports.listenTo = exports.validateListening = exports.listenToMany = exports.hasListener = undefined;\n\nvar _utils = require(\"./utils\");\n\nvar _ = _interopRequireWildcard(_utils);\n\nvar _joins = require(\"./joins\");\n\nfunction _interopRequireWildcard(obj) {\n  if (obj && obj.__esModule) {\n    return obj;\n  } else {\n    var newObj = {};\n\n    if (obj != null) {\n      for (var key in obj) {\n        if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];\n      }\n    }\n\n    newObj.default = obj;\n    return newObj;\n  }\n}\n/**\r\n * Extract child listenables from a parent from their\r\n * children property and return them in a keyed Object\r\n *\r\n * @param {Object} listenable The parent listenable\r\n */\n\n\nvar mapChildListenables = function mapChildListenables(listenable) {\n  var i = 0,\n      children = {},\n      childName;\n\n  for (; i < (listenable.children || []).length; ++i) {\n    childName = listenable.children[i];\n\n    if (listenable[childName]) {\n      children[childName] = listenable[childName];\n    }\n  }\n\n  return children;\n};\n/**\r\n * Make a flat dictionary of all listenables including their\r\n * possible children (recursively), concatenating names in camelCase.\r\n *\r\n * @param {Object} listenables The top-level listenables\r\n */\n\n\nvar flattenListenables = function flattenListenables(listenables) {\n  var flattened = {};\n\n  for (var key in listenables) {\n    var listenable = listenables[key];\n    var childMap = mapChildListenables(listenable); // recursively flatten children\n\n    var children = flattenListenables(childMap); // add the primary listenable and chilren\n\n    flattened[key] = listenable;\n\n    for (var childKey in children) {\n      var childListenable = children[childKey];\n      flattened[key + _.capitalize(childKey)] = childListenable;\n    }\n  }\n\n  return flattened;\n};\n/**\r\n * An internal utility function used by `validateListening`\r\n *\r\n * @param {Action|Store} listenable The listenable we want to search for\r\n * @returns {Boolean} The result of a recursive search among `this.subscriptions`\r\n */\n\n\nvar hasListener = exports.hasListener = function hasListener(listenable) {\n  var i = 0,\n      j,\n      listener,\n      listenables;\n\n  for (; i < (this.subscriptions || []).length; ++i) {\n    listenables = [].concat(this.subscriptions[i].listenable);\n\n    for (j = 0; j < listenables.length; j++) {\n      listener = listenables[j];\n\n      if (listener === listenable || listener.hasListener && listener.hasListener(listenable)) {\n        return true;\n      }\n    }\n  }\n\n  return false;\n};\n/**\r\n * A convenience method that listens to all listenables in the given object.\r\n *\r\n * @param {Object} listenables An object of listenables. Keys will be used as callback method names.\r\n */\n\n\nvar listenToMany = exports.listenToMany = function listenToMany(listenables) {\n  var allListenables = flattenListenables(listenables);\n\n  for (var key in allListenables) {\n    var cbname = _.callbackName(key),\n        localname = this[cbname] ? cbname : this[key] ? key : undefined;\n\n    if (localname) {\n      this.listenTo(allListenables[key], localname, this[cbname + \"Default\"] || this[localname + \"Default\"] || localname);\n    }\n  }\n};\n/**\r\n * Checks if the current context can listen to the supplied listenable\r\n *\r\n * @param {Action|Store} listenable An Action or Store that should be\r\n *  listened to.\r\n * @returns {String|Undefined} An error message, or undefined if there was no problem.\r\n */\n\n\nvar validateListening = exports.validateListening = function validateListening(listenable) {\n  if (listenable === this) {\n    return \"Listener is not able to listen to itself\";\n  }\n\n  if (!_.isFunction(listenable.listen)) {\n    return listenable + \" is missing a listen method\";\n  }\n\n  if (listenable.hasListener && listenable.hasListener(this)) {\n    return \"Listener cannot listen to this listenable because of circular loop\";\n  }\n};\n/**\r\n * Sets up a subscription to the given listenable for the context object\r\n *\r\n * @param {Action|Store} listenable An Action or Store that should be\r\n *  listened to.\r\n * @param {Function|String} callback The callback to register as event handler\r\n * @param {Function|String} defaultCallback The callback to register as default handler\r\n * @returns {Object} A subscription obj where `stop` is an unsub function and `listenable` is the object being listened to\r\n */\n\n\nvar listenTo = exports.listenTo = function listenTo(listenable, callback, defaultCallback) {\n  var desub,\n      unsubscriber,\n      subscriptionobj,\n      subs = this.subscriptions = this.subscriptions || [];\n\n  _.throwIf(this.validateListening(listenable));\n\n  this.fetchInitialState(listenable, defaultCallback);\n  desub = listenable.listen(this[callback] || callback, this);\n\n  unsubscriber = function unsubscriber() {\n    var index = subs.indexOf(subscriptionobj);\n\n    _.throwIf(index === -1, \"Tried to remove listen already gone from subscriptions list!\");\n\n    subs.splice(index, 1);\n    desub();\n  };\n\n  subscriptionobj = {\n    stop: unsubscriber,\n    listenable: listenable\n  };\n  subs.push(subscriptionobj);\n  return subscriptionobj;\n};\n/**\r\n * Stops listening to a single listenable\r\n *\r\n * @param {Action|Store} listenable The action or store we no longer want to listen to\r\n * @returns {Boolean} True if a subscription was found and removed, otherwise false.\r\n */\n\n\nvar stopListeningTo = exports.stopListeningTo = function stopListeningTo(listenable) {\n  var sub,\n      i = 0,\n      subs = this.subscriptions || [];\n\n  for (; i < subs.length; i++) {\n    sub = subs[i];\n\n    if (sub.listenable === listenable) {\n      sub.stop();\n\n      _.throwIf(subs.indexOf(sub) !== -1, \"Failed to remove listen from subscriptions list!\");\n\n      return true;\n    }\n  }\n\n  return false;\n};\n/**\r\n * Stops all subscriptions and empties subscriptions array\r\n */\n\n\nvar stopListeningToAll = exports.stopListeningToAll = function stopListeningToAll() {\n  var remaining,\n      subs = this.subscriptions || [];\n\n  while (remaining = subs.length) {\n    subs[0].stop();\n\n    _.throwIf(subs.length !== remaining - 1, \"Failed to remove listen from subscriptions list!\");\n  }\n};\n/**\r\n * Used in `listenTo`. Fetches initial data from a publisher if it has a `getInitialState` method.\r\n * @param {Action|Store} listenable The publisher we want to get initial state from\r\n * @param {Function|String} defaultCallback The method to receive the data\r\n */\n\n\nvar fetchInitialState = exports.fetchInitialState = function fetchInitialState(listenable, defaultCallback) {\n  defaultCallback = defaultCallback && this[defaultCallback] || defaultCallback;\n  var me = this;\n\n  if (_.isFunction(defaultCallback) && _.isFunction(listenable.getInitialState)) {\n    var data = listenable.getInitialState();\n\n    if (data && _.isFunction(data.then)) {\n      data.then(function () {\n        defaultCallback.apply(me, arguments);\n      });\n    } else {\n      defaultCallback.call(this, data);\n    }\n  }\n};\n/**\r\n * The callback will be called once all listenables have triggered at least once.\r\n * It will be invoked with the last emission from each listenable.\r\n * @param {...Publishers} publishers Publishers that should be tracked.\r\n * @param {Function|String} callback The method to call when all publishers have emitted\r\n * @returns {Object} A subscription obj where `stop` is an unsub function and `listenable` is an array of listenables\r\n */\n\n\nvar joinTrailing = exports.joinTrailing = (0, _joins.instanceJoinCreator)(\"last\");\n/**\r\n * The callback will be called once all listenables have triggered at least once.\r\n * It will be invoked with the first emission from each listenable.\r\n * @param {...Publishers} publishers Publishers that should be tracked.\r\n * @param {Function|String} callback The method to call when all publishers have emitted\r\n * @returns {Object} A subscription obj where `stop` is an unsub function and `listenable` is an array of listenables\r\n */\n\nvar joinLeading = exports.joinLeading = (0, _joins.instanceJoinCreator)(\"first\");\n/**\r\n * The callback will be called once all listenables have triggered at least once.\r\n * It will be invoked with all emission from each listenable.\r\n * @param {...Publishers} publishers Publishers that should be tracked.\r\n * @param {Function|String} callback The method to call when all publishers have emitted\r\n * @returns {Object} A subscription obj where `stop` is an unsub function and `listenable` is an array of listenables\r\n */\n\nvar joinConcat = exports.joinConcat = (0, _joins.instanceJoinCreator)(\"all\");\n/**\r\n * The callback will be called once all listenables have triggered.\r\n * If a callback triggers twice before that happens, an error is thrown.\r\n * @param {...Publishers} publishers Publishers that should be tracked.\r\n * @param {Function|String} callback The method to call when all publishers have emitted\r\n * @returns {Object} A subscription obj where `stop` is an unsub function and `listenable` is an array of listenables\r\n */\n\nvar joinStrict = exports.joinStrict = (0, _joins.instanceJoinCreator)(\"strict\");","map":{"version":3,"sources":["/home/tudor/work/sd/project/frontend/node_modules/reflux-core/lib/ListenerMethods.js"],"names":["Object","defineProperty","exports","value","joinStrict","joinConcat","joinLeading","joinTrailing","fetchInitialState","stopListeningToAll","stopListeningTo","listenTo","validateListening","listenToMany","hasListener","undefined","_utils","require","_","_interopRequireWildcard","_joins","obj","__esModule","newObj","key","prototype","hasOwnProperty","call","default","mapChildListenables","listenable","i","children","childName","length","flattenListenables","listenables","flattened","childMap","childKey","childListenable","capitalize","j","listener","subscriptions","concat","allListenables","cbname","callbackName","localname","isFunction","listen","callback","defaultCallback","desub","unsubscriber","subscriptionobj","subs","throwIf","index","indexOf","splice","stop","push","sub","remaining","me","getInitialState","data","then","apply","arguments","instanceJoinCreator"],"mappings":"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","sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.joinStrict = exports.joinConcat = exports.joinLeading = exports.joinTrailing = exports.fetchInitialState = exports.stopListeningToAll = exports.stopListeningTo = exports.listenTo = exports.validateListening = exports.listenToMany = exports.hasListener = undefined;\n\nvar _utils = require(\"./utils\");\n\nvar _ = _interopRequireWildcard(_utils);\n\nvar _joins = require(\"./joins\");\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\n/**\r\n * Extract child listenables from a parent from their\r\n * children property and return them in a keyed Object\r\n *\r\n * @param {Object} listenable The parent listenable\r\n */\nvar mapChildListenables = function mapChildListenables(listenable) {\n    var i = 0,\n        children = {},\n        childName;\n    for (; i < (listenable.children || []).length; ++i) {\n        childName = listenable.children[i];\n        if (listenable[childName]) {\n            children[childName] = listenable[childName];\n        }\n    }\n    return children;\n};\n\n/**\r\n * Make a flat dictionary of all listenables including their\r\n * possible children (recursively), concatenating names in camelCase.\r\n *\r\n * @param {Object} listenables The top-level listenables\r\n */\nvar flattenListenables = function flattenListenables(listenables) {\n    var flattened = {};\n    for (var key in listenables) {\n        var listenable = listenables[key];\n        var childMap = mapChildListenables(listenable);\n\n        // recursively flatten children\n        var children = flattenListenables(childMap);\n\n        // add the primary listenable and chilren\n        flattened[key] = listenable;\n        for (var childKey in children) {\n            var childListenable = children[childKey];\n            flattened[key + _.capitalize(childKey)] = childListenable;\n        }\n    }\n\n    return flattened;\n};\n\n/**\r\n * An internal utility function used by `validateListening`\r\n *\r\n * @param {Action|Store} listenable The listenable we want to search for\r\n * @returns {Boolean} The result of a recursive search among `this.subscriptions`\r\n */\nvar hasListener = exports.hasListener = function hasListener(listenable) {\n    var i = 0,\n        j,\n        listener,\n        listenables;\n    for (; i < (this.subscriptions || []).length; ++i) {\n        listenables = [].concat(this.subscriptions[i].listenable);\n        for (j = 0; j < listenables.length; j++) {\n            listener = listenables[j];\n            if (listener === listenable || listener.hasListener && listener.hasListener(listenable)) {\n                return true;\n            }\n        }\n    }\n    return false;\n};\n\n/**\r\n * A convenience method that listens to all listenables in the given object.\r\n *\r\n * @param {Object} listenables An object of listenables. Keys will be used as callback method names.\r\n */\nvar listenToMany = exports.listenToMany = function listenToMany(listenables) {\n    var allListenables = flattenListenables(listenables);\n    for (var key in allListenables) {\n        var cbname = _.callbackName(key),\n            localname = this[cbname] ? cbname : this[key] ? key : undefined;\n        if (localname) {\n            this.listenTo(allListenables[key], localname, this[cbname + \"Default\"] || this[localname + \"Default\"] || localname);\n        }\n    }\n};\n\n/**\r\n * Checks if the current context can listen to the supplied listenable\r\n *\r\n * @param {Action|Store} listenable An Action or Store that should be\r\n *  listened to.\r\n * @returns {String|Undefined} An error message, or undefined if there was no problem.\r\n */\nvar validateListening = exports.validateListening = function validateListening(listenable) {\n    if (listenable === this) {\n        return \"Listener is not able to listen to itself\";\n    }\n    if (!_.isFunction(listenable.listen)) {\n        return listenable + \" is missing a listen method\";\n    }\n    if (listenable.hasListener && listenable.hasListener(this)) {\n        return \"Listener cannot listen to this listenable because of circular loop\";\n    }\n};\n\n/**\r\n * Sets up a subscription to the given listenable for the context object\r\n *\r\n * @param {Action|Store} listenable An Action or Store that should be\r\n *  listened to.\r\n * @param {Function|String} callback The callback to register as event handler\r\n * @param {Function|String} defaultCallback The callback to register as default handler\r\n * @returns {Object} A subscription obj where `stop` is an unsub function and `listenable` is the object being listened to\r\n */\nvar listenTo = exports.listenTo = function listenTo(listenable, callback, defaultCallback) {\n    var desub,\n        unsubscriber,\n        subscriptionobj,\n        subs = this.subscriptions = this.subscriptions || [];\n    _.throwIf(this.validateListening(listenable));\n    this.fetchInitialState(listenable, defaultCallback);\n    desub = listenable.listen(this[callback] || callback, this);\n    unsubscriber = function unsubscriber() {\n        var index = subs.indexOf(subscriptionobj);\n        _.throwIf(index === -1, \"Tried to remove listen already gone from subscriptions list!\");\n        subs.splice(index, 1);\n        desub();\n    };\n    subscriptionobj = {\n        stop: unsubscriber,\n        listenable: listenable\n    };\n    subs.push(subscriptionobj);\n    return subscriptionobj;\n};\n\n/**\r\n * Stops listening to a single listenable\r\n *\r\n * @param {Action|Store} listenable The action or store we no longer want to listen to\r\n * @returns {Boolean} True if a subscription was found and removed, otherwise false.\r\n */\nvar stopListeningTo = exports.stopListeningTo = function stopListeningTo(listenable) {\n    var sub,\n        i = 0,\n        subs = this.subscriptions || [];\n    for (; i < subs.length; i++) {\n        sub = subs[i];\n        if (sub.listenable === listenable) {\n            sub.stop();\n            _.throwIf(subs.indexOf(sub) !== -1, \"Failed to remove listen from subscriptions list!\");\n            return true;\n        }\n    }\n    return false;\n};\n\n/**\r\n * Stops all subscriptions and empties subscriptions array\r\n */\nvar stopListeningToAll = exports.stopListeningToAll = function stopListeningToAll() {\n    var remaining,\n        subs = this.subscriptions || [];\n    while (remaining = subs.length) {\n        subs[0].stop();\n        _.throwIf(subs.length !== remaining - 1, \"Failed to remove listen from subscriptions list!\");\n    }\n};\n\n/**\r\n * Used in `listenTo`. Fetches initial data from a publisher if it has a `getInitialState` method.\r\n * @param {Action|Store} listenable The publisher we want to get initial state from\r\n * @param {Function|String} defaultCallback The method to receive the data\r\n */\nvar fetchInitialState = exports.fetchInitialState = function fetchInitialState(listenable, defaultCallback) {\n    defaultCallback = defaultCallback && this[defaultCallback] || defaultCallback;\n    var me = this;\n    if (_.isFunction(defaultCallback) && _.isFunction(listenable.getInitialState)) {\n        var data = listenable.getInitialState();\n        if (data && _.isFunction(data.then)) {\n            data.then(function () {\n                defaultCallback.apply(me, arguments);\n            });\n        } else {\n            defaultCallback.call(this, data);\n        }\n    }\n};\n\n/**\r\n * The callback will be called once all listenables have triggered at least once.\r\n * It will be invoked with the last emission from each listenable.\r\n * @param {...Publishers} publishers Publishers that should be tracked.\r\n * @param {Function|String} callback The method to call when all publishers have emitted\r\n * @returns {Object} A subscription obj where `stop` is an unsub function and `listenable` is an array of listenables\r\n */\nvar joinTrailing = exports.joinTrailing = (0, _joins.instanceJoinCreator)(\"last\");\n\n/**\r\n * The callback will be called once all listenables have triggered at least once.\r\n * It will be invoked with the first emission from each listenable.\r\n * @param {...Publishers} publishers Publishers that should be tracked.\r\n * @param {Function|String} callback The method to call when all publishers have emitted\r\n * @returns {Object} A subscription obj where `stop` is an unsub function and `listenable` is an array of listenables\r\n */\nvar joinLeading = exports.joinLeading = (0, _joins.instanceJoinCreator)(\"first\");\n\n/**\r\n * The callback will be called once all listenables have triggered at least once.\r\n * It will be invoked with all emission from each listenable.\r\n * @param {...Publishers} publishers Publishers that should be tracked.\r\n * @param {Function|String} callback The method to call when all publishers have emitted\r\n * @returns {Object} A subscription obj where `stop` is an unsub function and `listenable` is an array of listenables\r\n */\nvar joinConcat = exports.joinConcat = (0, _joins.instanceJoinCreator)(\"all\");\n\n/**\r\n * The callback will be called once all listenables have triggered.\r\n * If a callback triggers twice before that happens, an error is thrown.\r\n * @param {...Publishers} publishers Publishers that should be tracked.\r\n * @param {Function|String} callback The method to call when all publishers have emitted\r\n * @returns {Object} A subscription obj where `stop` is an unsub function and `listenable` is an array of listenables\r\n */\nvar joinStrict = exports.joinStrict = (0, _joins.instanceJoinCreator)(\"strict\");"]},"metadata":{},"sourceType":"script"}