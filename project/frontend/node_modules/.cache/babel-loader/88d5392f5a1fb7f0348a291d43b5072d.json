{"ast":null,"code":"import Reflux from 'reflux';\nimport GlobalAlertActions from '../actions/GlobalAlert';\n\nclass GlobalAlertStore extends Reflux.Store {\n  // how long a message will be displayed ms\n  constructor() {\n    super();\n    this.alertTime = 5000;\n    this.state = {\n      alerts: []\n    };\n    this.listenTo(GlobalAlertActions.add, this.add);\n    this.listenTo(GlobalAlertActions.remove, this.remove);\n  }\n\n  add(message, type) {\n    let alerts = this.state.alerts;\n    let randomKey = Math.random() * 100000000; // Getting a random key to uniquely identify the current alert and\n    // remove it with the timeout, and also keep the timeout id to stop\n    // it in case the user dismisses the alert\n\n    alerts.push({\n      message: message,\n      type: type,\n      randomKey: randomKey,\n      timeout: setTimeout(() => {\n        this.removeKey(randomKey);\n      }, this.alertTime)\n    });\n    this.setState({\n      alerts: alerts\n    });\n  }\n\n  removeKey(randomKey) {\n    let alerts = this.state.alerts;\n\n    for (let i = 0; i < alerts.length; i++) {\n      if (alerts[i].randomKey === randomKey) {\n        alerts.splice(i, 1);\n        break;\n      }\n    }\n\n    this.setState({\n      alerts: alerts\n    });\n  }\n\n  remove(index) {\n    let alerts = this.state.alerts;\n    clearTimeout(alerts[index].timeout);\n    alerts.splice(index, 1);\n    this.setState({\n      alerts: alerts\n    });\n  }\n\n}\n\nexport default GlobalAlertStore;","map":{"version":3,"sources":["/home/tudor/work/sd/assignment-3-Lolkekzor/project/frontend/src/reflux/stores/GlobalAlert.js"],"names":["Reflux","GlobalAlertActions","GlobalAlertStore","Store","constructor","alertTime","state","alerts","listenTo","add","remove","message","type","randomKey","Math","random","push","timeout","setTimeout","removeKey","setState","i","length","splice","index","clearTimeout"],"mappings":"AAAA,OAAOA,MAAP,MAAmB,QAAnB;AACA,OAAOC,kBAAP,MAA+B,wBAA/B;;AAEA,MAAMC,gBAAN,SAA+BF,MAAM,CAACG,KAAtC,CAA2C;AAErB;AAElBC,EAAAA,WAAW,GAAE;AACT;AADS,SAFbC,SAEa,GAFD,IAEC;AAET,SAAKC,KAAL,GAAa;AACTC,MAAAA,MAAM,EAAE;AADC,KAAb;AAGA,SAAKC,QAAL,CAAcP,kBAAkB,CAACQ,GAAjC,EAAsC,KAAKA,GAA3C;AACA,SAAKD,QAAL,CAAcP,kBAAkB,CAACS,MAAjC,EAAyC,KAAKA,MAA9C;AACH;;AAEDD,EAAAA,GAAG,CAACE,OAAD,EAAUC,IAAV,EAAe;AACd,QAAIL,MAAM,GAAG,KAAKD,KAAL,CAAWC,MAAxB;AACA,QAAIM,SAAS,GAAGC,IAAI,CAACC,MAAL,KAAgB,SAAhC,CAFc,CAGd;AACA;AACA;;AACAR,IAAAA,MAAM,CAACS,IAAP,CAAY;AACRL,MAAAA,OAAO,EAAEA,OADD;AAERC,MAAAA,IAAI,EAAEA,IAFE;AAGRC,MAAAA,SAAS,EAAEA,SAHH;AAIRI,MAAAA,OAAO,EAAEC,UAAU,CAAE,MAAI;AAAC,aAAKC,SAAL,CAAeN,SAAf;AAA0B,OAAjC,EAAmC,KAAKR,SAAxC;AAJX,KAAZ;AAMA,SAAKe,QAAL,CAAc;AACVb,MAAAA,MAAM,EAAEA;AADE,KAAd;AAGH;;AAEDY,EAAAA,SAAS,CAACN,SAAD,EAAW;AAChB,QAAIN,MAAM,GAAG,KAAKD,KAAL,CAAWC,MAAxB;;AACA,SAAI,IAAIc,CAAC,GAAG,CAAZ,EAAgBA,CAAC,GAAGd,MAAM,CAACe,MAA3B,EAAoCD,CAAC,EAArC,EAAwC;AACpC,UAAGd,MAAM,CAACc,CAAD,CAAN,CAAUR,SAAV,KAAwBA,SAA3B,EAAqC;AACjCN,QAAAA,MAAM,CAACgB,MAAP,CAAcF,CAAd,EAAiB,CAAjB;AACA;AACH;AACJ;;AACD,SAAKD,QAAL,CAAc;AACVb,MAAAA,MAAM,EAAEA;AADE,KAAd;AAGH;;AAEDG,EAAAA,MAAM,CAACc,KAAD,EAAO;AACT,QAAIjB,MAAM,GAAG,KAAKD,KAAL,CAAWC,MAAxB;AACAkB,IAAAA,YAAY,CAAClB,MAAM,CAACiB,KAAD,CAAN,CAAcP,OAAf,CAAZ;AACAV,IAAAA,MAAM,CAACgB,MAAP,CAAcC,KAAd,EAAqB,CAArB;AACA,SAAKJ,QAAL,CAAc;AACVb,MAAAA,MAAM,EAAEA;AADE,KAAd;AAGH;;AAlDsC;;AAsD3C,eAAeL,gBAAf","sourcesContent":["import Reflux from 'reflux';\nimport GlobalAlertActions from '../actions/GlobalAlert';\n\nclass GlobalAlertStore extends Reflux.Store{\n\n    alertTime = 5000; // how long a message will be displayed ms\n\n    constructor(){\n        super();\n        this.state = {\n            alerts: []\n        }\n        this.listenTo(GlobalAlertActions.add, this.add);\n        this.listenTo(GlobalAlertActions.remove, this.remove);\n    }\n\n    add(message, type){\n        let alerts = this.state.alerts;\n        let randomKey = Math.random() * 100000000;\n        // Getting a random key to uniquely identify the current alert and\n        // remove it with the timeout, and also keep the timeout id to stop\n        // it in case the user dismisses the alert\n        alerts.push({\n            message: message,\n            type: type,\n            randomKey: randomKey,\n            timeout: setTimeout( ()=>{this.removeKey(randomKey)}, this.alertTime )\n        });\n        this.setState({\n            alerts: alerts\n        });\n    }\n\n    removeKey(randomKey){\n        let alerts = this.state.alerts;\n        for(let i = 0 ; i < alerts.length ; i++){\n            if(alerts[i].randomKey === randomKey){\n                alerts.splice(i, 1);\n                break;\n            }\n        }\n        this.setState({\n            alerts: alerts\n        });\n    }\n\n    remove(index){\n        let alerts = this.state.alerts;\n        clearTimeout(alerts[index].timeout);\n        alerts.splice(index, 1);\n        this.setState({\n            alerts: alerts\n        });\n    }\n\n}\n\nexport default GlobalAlertStore;\n"]},"metadata":{},"sourceType":"module"}