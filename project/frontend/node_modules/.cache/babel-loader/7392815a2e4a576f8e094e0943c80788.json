{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.staticJoinCreator = staticJoinCreator;\nexports.instanceJoinCreator = instanceJoinCreator;\n\nvar _createStore = require(\"./createStore\");\n\nvar _utils = require(\"./utils\");\n\nvar _ = _interopRequireWildcard(_utils);\n\nfunction _interopRequireWildcard(obj) {\n  if (obj && obj.__esModule) {\n    return obj;\n  } else {\n    var newObj = {};\n\n    if (obj != null) {\n      for (var key in obj) {\n        if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];\n      }\n    }\n\n    newObj.default = obj;\n    return newObj;\n  }\n}\n/**\r\n * Internal module used to create static and instance join methods\r\n */\n\n\nvar slice = Array.prototype.slice,\n    strategyMethodNames = {\n  strict: \"joinStrict\",\n  first: \"joinLeading\",\n  last: \"joinTrailing\",\n  all: \"joinConcat\"\n};\n/**\r\n * Used in `index.js` to create the static join methods\r\n * @param {String} strategy Which strategy to use when tracking listenable trigger arguments\r\n * @returns {Function} A static function which returns a store with a join listen on the given listenables using the given strategy\r\n */\n\nfunction staticJoinCreator(strategy) {\n  return function ()\n  /* listenables... */\n  {\n    var listenables = slice.call(arguments);\n    return (0, _createStore.createStore)({\n      init: function init() {\n        this[strategyMethodNames[strategy]].apply(this, listenables.concat(\"triggerAsync\"));\n      }\n    });\n  };\n}\n/**\r\n * Used in `ListenerMethods.js` to create the instance join methods\r\n * @param {String} strategy Which strategy to use when tracking listenable trigger arguments\r\n * @returns {Function} An instance method which sets up a join listen on the given listenables using the given strategy\r\n */\n\n\nfunction instanceJoinCreator(strategy) {\n  return function ()\n  /* listenables..., callback*/\n  {\n    _.throwIf(arguments.length < 2, \"Cannot create a join with less than 2 listenables!\");\n\n    var listenables = slice.call(arguments),\n        callback = listenables.pop(),\n        numberOfListenables = listenables.length,\n        join = {\n      numberOfListenables: numberOfListenables,\n      callback: this[callback] || callback,\n      listener: this,\n      strategy: strategy\n    },\n        i,\n        cancels = [],\n        subobj;\n\n    for (i = 0; i < numberOfListenables; i++) {\n      _.throwIf(this.validateListening(listenables[i]));\n    }\n\n    for (i = 0; i < numberOfListenables; i++) {\n      cancels.push(listenables[i].listen(newListener(i, join), this));\n    }\n\n    reset(join);\n    subobj = {\n      listenable: listenables\n    };\n    subobj.stop = makeStopper(subobj, cancels, this);\n    this.subscriptions = (this.subscriptions || []).concat(subobj);\n    return subobj;\n  };\n} // ---- internal join functions ----\n\n\nfunction makeStopper(subobj, cancels, context) {\n  return function () {\n    var i,\n        subs = context.subscriptions,\n        index = subs ? subs.indexOf(subobj) : -1;\n\n    _.throwIf(index === -1, \"Tried to remove join already gone from subscriptions list!\");\n\n    for (i = 0; i < cancels.length; i++) {\n      cancels[i]();\n    }\n\n    subs.splice(index, 1);\n  };\n}\n\nfunction reset(join) {\n  join.listenablesEmitted = new Array(join.numberOfListenables);\n  join.args = new Array(join.numberOfListenables);\n}\n\nfunction newListener(i, join) {\n  return function () {\n    var callargs = slice.call(arguments);\n\n    if (join.listenablesEmitted[i]) {\n      switch (join.strategy) {\n        case \"strict\":\n          throw new Error(\"Strict join failed because listener triggered twice.\");\n\n        case \"last\":\n          join.args[i] = callargs;\n          break;\n\n        case \"all\":\n          join.args[i].push(callargs);\n      }\n    } else {\n      join.listenablesEmitted[i] = true;\n      join.args[i] = join.strategy === \"all\" ? [callargs] : callargs;\n    }\n\n    emitIfAllListenablesEmitted(join);\n  };\n}\n\nfunction emitIfAllListenablesEmitted(join) {\n  for (var i = 0; i < join.numberOfListenables; i++) {\n    if (!join.listenablesEmitted[i]) {\n      return;\n    }\n  }\n\n  join.callback.apply(join.listener, join.args);\n  reset(join);\n}","map":{"version":3,"sources":["/home/tudor/work/sd/assignment-3-Lolkekzor/project/frontend/node_modules/reflux-core/lib/joins.js"],"names":["Object","defineProperty","exports","value","staticJoinCreator","instanceJoinCreator","_createStore","require","_utils","_","_interopRequireWildcard","obj","__esModule","newObj","key","prototype","hasOwnProperty","call","default","slice","Array","strategyMethodNames","strict","first","last","all","strategy","listenables","arguments","createStore","init","apply","concat","throwIf","length","callback","pop","numberOfListenables","join","listener","i","cancels","subobj","validateListening","push","listen","newListener","reset","listenable","stop","makeStopper","subscriptions","context","subs","index","indexOf","splice","listenablesEmitted","args","callargs","Error","emitIfAllListenablesEmitted"],"mappings":"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","sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.staticJoinCreator = staticJoinCreator;\nexports.instanceJoinCreator = instanceJoinCreator;\n\nvar _createStore = require(\"./createStore\");\n\nvar _utils = require(\"./utils\");\n\nvar _ = _interopRequireWildcard(_utils);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\n/**\r\n * Internal module used to create static and instance join methods\r\n */\n\nvar slice = Array.prototype.slice,\n    strategyMethodNames = {\n    strict: \"joinStrict\",\n    first: \"joinLeading\",\n    last: \"joinTrailing\",\n    all: \"joinConcat\"\n};\n\n/**\r\n * Used in `index.js` to create the static join methods\r\n * @param {String} strategy Which strategy to use when tracking listenable trigger arguments\r\n * @returns {Function} A static function which returns a store with a join listen on the given listenables using the given strategy\r\n */\nfunction staticJoinCreator(strategy) {\n    return function () /* listenables... */{\n        var listenables = slice.call(arguments);\n        return (0, _createStore.createStore)({\n            init: function init() {\n                this[strategyMethodNames[strategy]].apply(this, listenables.concat(\"triggerAsync\"));\n            }\n        });\n    };\n}\n\n/**\r\n * Used in `ListenerMethods.js` to create the instance join methods\r\n * @param {String} strategy Which strategy to use when tracking listenable trigger arguments\r\n * @returns {Function} An instance method which sets up a join listen on the given listenables using the given strategy\r\n */\nfunction instanceJoinCreator(strategy) {\n    return function () /* listenables..., callback*/{\n        _.throwIf(arguments.length < 2, \"Cannot create a join with less than 2 listenables!\");\n        var listenables = slice.call(arguments),\n            callback = listenables.pop(),\n            numberOfListenables = listenables.length,\n            join = {\n            numberOfListenables: numberOfListenables,\n            callback: this[callback] || callback,\n            listener: this,\n            strategy: strategy\n        },\n            i,\n            cancels = [],\n            subobj;\n        for (i = 0; i < numberOfListenables; i++) {\n            _.throwIf(this.validateListening(listenables[i]));\n        }\n        for (i = 0; i < numberOfListenables; i++) {\n            cancels.push(listenables[i].listen(newListener(i, join), this));\n        }\n        reset(join);\n        subobj = { listenable: listenables };\n        subobj.stop = makeStopper(subobj, cancels, this);\n        this.subscriptions = (this.subscriptions || []).concat(subobj);\n        return subobj;\n    };\n}\n\n// ---- internal join functions ----\n\nfunction makeStopper(subobj, cancels, context) {\n    return function () {\n        var i,\n            subs = context.subscriptions,\n            index = subs ? subs.indexOf(subobj) : -1;\n        _.throwIf(index === -1, \"Tried to remove join already gone from subscriptions list!\");\n        for (i = 0; i < cancels.length; i++) {\n            cancels[i]();\n        }\n        subs.splice(index, 1);\n    };\n}\n\nfunction reset(join) {\n    join.listenablesEmitted = new Array(join.numberOfListenables);\n    join.args = new Array(join.numberOfListenables);\n}\n\nfunction newListener(i, join) {\n    return function () {\n        var callargs = slice.call(arguments);\n        if (join.listenablesEmitted[i]) {\n            switch (join.strategy) {\n                case \"strict\":\n                    throw new Error(\"Strict join failed because listener triggered twice.\");\n                case \"last\":\n                    join.args[i] = callargs;break;\n                case \"all\":\n                    join.args[i].push(callargs);\n            }\n        } else {\n            join.listenablesEmitted[i] = true;\n            join.args[i] = join.strategy === \"all\" ? [callargs] : callargs;\n        }\n        emitIfAllListenablesEmitted(join);\n    };\n}\n\nfunction emitIfAllListenablesEmitted(join) {\n    for (var i = 0; i < join.numberOfListenables; i++) {\n        if (!join.listenablesEmitted[i]) {\n            return;\n        }\n    }\n    join.callback.apply(join.listener, join.args);\n    reset(join);\n}"]},"metadata":{},"sourceType":"script"}